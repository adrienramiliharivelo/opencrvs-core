{
    "sourceFile": "packages/client/src/components/formConfig/formTools/CustomFieldTools.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1677231903776,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1677231903776,
            "name": "Commit-0",
            "content": "/*\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n *\n * OpenCRVS is also distributed under the terms of the Civil Registration\n * & Healthcare Disclaimer located at http://opencrvs.org/license.\n *\n * Copyright (C) The OpenCRVS Authors. OpenCRVS and the OpenCRVS\n * graphic logo are (registered/a) trademark(s) of Plan International.\n */\nimport {\n  NUMBER,\n  TEL,\n  TEXT,\n  TEXTAREA,\n  BirthSection,\n  DeathSection,\n  IFormField,\n  SELECT_WITH_OPTIONS,\n  ISelectOption,\n  IFormDataSet\n} from '@client/forms'\nimport {\n  getIdentifiersFromFieldId,\n  ICustomSelectOption,\n  IMessage\n} from '@client/forms/questionConfig'\nimport { CreateFormDatasetMutation, Event } from '@client/utils/gateway'\nimport { modifyConfigField } from '@client/forms/configuration/formConfig/actions'\nimport {\n  getCertificateHandlebar,\n  ICustomConfigField,\n  IDataSourceSelectOption,\n  isPreviewGroupConfigField\n} from '@client/forms/configuration/formConfig/utils'\nimport {\n  buttonMessages,\n  formMessageDescriptors,\n  locationMessages\n} from '@client/i18n/messages'\nimport { customFieldFormMessages } from '@client/i18n/messages/views/customFieldForm'\nimport {\n  ILanguageState,\n  initLanguages,\n  IntlMessages\n} from '@client/i18n/reducer'\nimport { getDefaultLanguage } from '@client/i18n/utils'\nimport { IStoreState } from '@client/store'\nimport styled from '@client/styledComponents'\nimport { PrimaryButton } from '@opencrvs/components/lib/buttons'\nimport { Button } from '@opencrvs/components/src/Button'\nimport { InputField } from '@opencrvs/components/lib/InputField'\nimport { TextInput } from '@opencrvs/components/lib/TextInput'\nimport { TextArea } from '@opencrvs/components/lib/TextArea'\nimport { Link } from '@opencrvs/components/lib/Link'\nimport { Select } from '@opencrvs/components/lib/Select'\nimport { ErrorText } from '@opencrvs/components/lib/ErrorText'\nimport {\n  ListViewSimplified,\n  ListViewItemSimplified\n} from '@opencrvs/components/lib/ListViewSimplified'\nimport { camelCase, debounce, isEmpty } from 'lodash'\nimport * as React from 'react'\nimport {\n  injectIntl,\n  MessageDescriptor,\n  WrappedComponentProps as IntlShapeProp\n} from 'react-intl'\nimport { connect } from 'react-redux'\nimport { selectConfigFields } from '@client/forms/configuration/formConfig/selectors'\nimport { useFieldDefinition } from '@client/views/SysAdmin/Config/Forms/hooks'\nimport {\n  Title,\n  Label,\n  RequiredToggleAction,\n  ToolTip,\n  ConditionalToggleAction,\n  RegisterFormFieldIds\n} from './components'\nimport { messages } from '@client/i18n/messages/views/formConfig'\nimport { Text } from '@opencrvs/components/lib/Text'\nimport { EMPTY_STRING } from '@client/utils/constants'\nimport { Stack } from '@opencrvs/components/lib/Stack'\nimport { FileSelectLink } from '@opencrvs/components/lib/FileSelectLink'\nimport { getBase64String } from '@client/utils/imageUtils'\nimport { ResponsiveModal } from '@client/../../components/lib'\nimport { client } from '@client/utils/apolloClient'\nimport { CREATE_FORM_DATA_SET } from '@client/views/SysAdmin/Config/Forms/mutations'\nimport { Alert } from '@opencrvs/components/lib/Alert'\nimport { createCustomFieldHandlebarName } from '@client/forms/configuration/customUtils'\nimport { offlineFormConfigAddFormDataset } from '@client/offline/actions'\nimport { Icon } from '@opencrvs/components/lib/Icon'\n\nconst DEFAULT_MAX_LENGTH = 250\n\nconst CInputField = styled(InputField)`\n  label {\n    ${({ theme }) => theme.fonts.reg14};\n  }\n`\n\nconst CTextInput = styled(TextInput)`\n  ${({ theme }) => theme.fonts.reg14};\n  height: 32px;\n  border: solid 1px ${({ theme }) => theme.colors.grey600};\n`\nconst CSelect = styled(Select)`\n  width: 100%;\n  margin: 20px 0px;\n  border-radius: 2px;\n  .react-select__control {\n    border: solid 1px ${({ theme }) => theme.colors.grey600};\n    max-height: 32px;\n    min-height: 32px;\n  }\n  .react-select__control:hover {\n    border: solid 1px ${({ theme }) => theme.colors.grey600};\n  }\n  .react-select__placeholder {\n    color: ${({ theme }) => theme.colors.grey400};\n  }\n  .react-select__value-container {\n    display: block;\n  }\n  div {\n    ${({ theme }) => theme.fonts.reg14};\n    color: ${({ theme }) => theme.colors.primaryDark};\n  }\n`\n\nconst ConditionalWrapper = styled.div`\n  display: flex;\n  flex-direction: column;\n  gap: 18px;\n  padding-bottom: 30px;\n  border-bottom: 1px solid ${({ theme }) => theme.colors.grey200};\n`\n\nconst CTextArea = styled(TextArea)`\n  ${({ theme }) => theme.fonts.reg14};\n  height: 32px;\n  background: ${({ theme }) => theme.colors.white};\n  border: solid 1px ${({ theme }) => theme.colors.grey600};\n`\n\nconst CPrimaryButton = styled(PrimaryButton)`\n  border-radius: 4px;\n  margin-bottom: 24px;\n  :disabled {\n    background: ${({ theme }) => theme.colors.grey300};\n  }\n`\n\nconst FieldContainer = styled.div<{ hide?: boolean }>`\n  margin-bottom: 30px;\n  ${({ hide }) => {\n    return hide ? 'display: none' : 'display: block'\n  }}\n`\n\nconst ListContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n  margin-bottom: 26px;\n`\n\nconst ListRow = styled.div`\n  ${({ theme }) => theme.fonts.reg14};\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  border-bottom: solid 1px ${({ theme }) => theme.colors.grey200};\n  padding: 8px 0;\n`\n\nconst LanguageSelect = styled(Select)`\n  width: 175px;\n  border: solid 2px ${({ theme }) => theme.colors.primaryDark};\n  border-radius: 2px;\n  .react-select__control {\n    max-height: 32px;\n    min-height: 32px;\n  }\n  .react-select__value-container {\n    display: block;\n  }\n  div {\n    ${({ theme }) => theme.fonts.reg14};\n    color: ${({ theme }) => theme.colors.primaryDark};\n  }\n`\nconst ConditionalFieldIdSelect = styled(Select)`\n  width: 100%;\n  border: solid 2px ${({ theme }) => theme.colors.primaryDark};\n  border-radius: 2px;\n  .react-select__control {\n    max-height: 32px;\n    min-height: 32px;\n  }\n  .react-select__value-container {\n    display: block;\n  }\n  div {\n    ${({ theme }) => theme.fonts.reg14};\n    color: ${({ theme }) => theme.colors.primaryDark};\n  }\n`\n\nconst ListColumn = styled.div`\n  display: flex;\n  align-items: center;\n  gap: 4px;\n`\n\nconst CErrorText = styled(ErrorText)`\n  width: 200px;\n`\nconst Body = styled.div`\n  margin: 16px 0px;\n`\n\nconst CustomSelectHeading = styled.span`\n  display: flex;\n  gap: 5px;\n`\n\nconst CFileSelectLink = styled(FileSelectLink)`\n  border: 2px solid ${({ theme }) => theme.colors.primary};\n  border-radius: 4px;\n  color: ${({ theme }) => theme.colors.primary};\n  padding: 0px 12px;\n  height: 40px;\n\n  &:hover {\n    text-decoration: underline;\n    background: ${({ theme }) => theme.colors.grey100};\n    border: 2px solid ${({ theme }) => theme.colors.primaryDark};\n    color: ${({ theme }) => theme.colors.primaryDark};\n  }\n  &:active {\n    background: ${({ theme }) => theme.colors.grey200};\n    color: ${({ theme }) => theme.colors.primaryDarker};\n  }\n  &:focus-visible {\n    border: 2px solid ${({ theme }) => theme.colors.grey600};\n    background: ${({ theme }) => theme.colors.yellow};\n    color: ${({ theme }) => theme.colors.grey600};\n    box-shadow: none;\n  }\n`\n\ntype IFormFieldWrapper = { formField: IFormField }\n\ntype IProps = {\n  event: Event\n  selectedField: ICustomConfigField\n  section: BirthSection | DeathSection\n  setSelectedField: React.Dispatch<React.SetStateAction<string | null>>\n}\n\ntype IFullProps = IProps &\n  IFormFieldWrapper &\n  IntlShapeProp &\n  ReturnType<typeof mapStateToProps> &\n  typeof mapDispatchToProps\n\ninterface ICustomField {\n  label: string\n  placeholder: string\n  description: string\n  tooltip: string\n  errorMessage: string\n}\n\ninterface IFieldForms {\n  [key: string]: ICustomField\n}\ninterface IConditionalFieldForms {\n  fieldId: string\n  regex: string\n}\n\nenum STATUS_TYPES {\n  INPROGRESS = 'loading',\n  COMPLETED = 'success',\n  ERROR = 'error'\n}\n\ninterface CSVUploadStatus {\n  statusType: STATUS_TYPES\n  message: string\n}\n\ninterface ICustomFieldState {\n  selectedLanguage: string\n  conditionalField: IConditionalFieldForms\n  handleBars: string\n  maxLength: number\n  fieldForms: IFieldForms\n  showCSVUploadingModal: boolean\n  CSVUploadStatuses: CSVUploadStatus[]\n  CSVUploaderModalActions: JSX.Element[]\n  dataSourceSelectOptions: IDataSourceSelectOption[]\n  selectedDataSource: string | null | undefined\n}\n\ninterface IOptionalContent {\n  [key: string]: IMessage[]\n}\n\nclass CustomFieldToolsComp extends React.Component<\n  IFullProps,\n  ICustomFieldState\n> {\n  constructor(props: IFullProps) {\n    super(props)\n    this.state = this.getInitialState()\n  }\n\n  prepareDataSourceOptions(\n    formDataset: IFormDataSet[]\n  ): IDataSourceSelectOption[] {\n    const { selectedLanguage, intl } = this.props\n\n    const dataSourceOptions =\n      formDataset.map((dataset) => {\n        const optionsFromCSV = dataset?.options\n          ?.map((option) => {\n            const label = option?.label\n              ? option.label.find((i) => i?.lang === selectedLanguage)\n              : null\n\n            if (label) {\n              return {\n                value: option.value,\n                label: label.descriptor\n              } as ISelectOption\n            }\n          })\n          .filter((i) => i) as ISelectOption[]\n\n        const datasetResourceLabel: { [key: string]: MessageDescriptor } = {\n          HEALTH_FACILITY: formMessageDescriptors.healthInstitution,\n          STATE: locationMessages.STATE,\n          DISTRICT: locationMessages.DISTRICT,\n          LOCATION_LEVEL_3: locationMessages.LOCATION_LEVEL_3,\n          LOCATION_LEVEL_4: locationMessages.LOCATION_LEVEL_4,\n          LOCATION_LEVEL_5: locationMessages.LOCATION_LEVEL_5\n        }\n        let label = dataset.fileName\n        if (dataset.resource && dataset.resource in datasetResourceLabel) {\n          label = intl.formatMessage(datasetResourceLabel[dataset.resource])\n        }\n        return {\n          value: dataset._id,\n          label,\n          options: optionsFromCSV\n        }\n      }) || []\n    for (let i = dataSourceOptions.length - 1; i >= 0; --i) {\n      if (dataSourceOptions[i].options.length === 0) {\n        dataSourceOptions.splice(i, 1)\n      }\n    }\n    return dataSourceOptions\n  }\n\n  componentDidUpdate({ selectedField: { fieldId } }: IFullProps) {\n    if (fieldId !== this.props.selectedField.fieldId) {\n      this.setState(this.getInitialState())\n    }\n  }\n\n  getInitialState() {\n    const defaultLanguage = getDefaultLanguage()\n    const languages = this.getLanguages()\n    const { selectedField, formField } = this.props\n    const fieldForms: { [key: string]: ICustomField } = {}\n    const conditionalfield = selectedField.conditionals?.[0]\n\n    Object.keys(languages).forEach((lang) => {\n      const label = this.getIntlMessage(selectedField.label, lang)\n      fieldForms[lang] = {\n        label,\n        placeholder: this.getIntlMessage(selectedField.placeholder, lang),\n        description: this.getIntlMessage(selectedField.description, lang),\n        tooltip: this.getIntlMessage(selectedField.tooltip, lang),\n        errorMessage: this.getIntlMessage(selectedField.errorMessage, lang)\n      }\n    })\n\n    return {\n      handleBars: camelCase(fieldForms[defaultLanguage].label),\n      selectedLanguage: defaultLanguage,\n      conditionalField: {\n        fieldId: conditionalfield?.fieldId ?? EMPTY_STRING,\n        regex: conditionalfield?.regexp ?? EMPTY_STRING\n      },\n      maxLength: selectedField.maxLength ?? DEFAULT_MAX_LENGTH,\n      fieldForms,\n      showCSVUploadingModal: false,\n      CSVUploadStatuses: [],\n      CSVUploaderModalActions: [],\n      dataSourceSelectOptions: this.prepareDataSourceOptions(\n        this.props.formDataset || []\n      ),\n      selectedDataSource: this.props.selectedField.datasetId\n    }\n  }\n\n  getIntlMessage(messages: IMessage[] | undefined, lang: string) {\n    if (!messages) return ''\n    const message = messages.find((message) => message.lang === lang)\n    return message && message.descriptor\n      ? message.descriptor.defaultMessage\n      : ''\n  }\n\n  getLanguages(): ILanguageState {\n    return initLanguages()\n  }\n\n  setConditionalFieldId(fieldId: string) {\n    this.setState({\n      conditionalField: {\n        ...this.state.conditionalField,\n        fieldId: fieldId\n      }\n    })\n  }\n\n  setValue(field: string, value: string) {\n    const language = this.state.selectedLanguage\n    this.setState({\n      fieldForms: {\n        ...this.state.fieldForms,\n        [language]: {\n          ...this.state.fieldForms[language],\n          [field]: value\n        }\n      }\n    })\n  }\n\n  isFormValid(): boolean {\n    for (const lang in this.getLanguages()) {\n      if (Boolean(this.state.fieldForms[lang].label) === false) return false\n    }\n    return true\n  }\n\n  isConditionalFormValid(): boolean {\n    if (this.props.selectedField.conditionals) {\n      return (\n        !!this.state.conditionalField.fieldId &&\n        !!this.state.conditionalField.regex\n      )\n    }\n    return true\n  }\n\n  generateNewFieldID() {\n    const { event, sectionId, groupId } = getIdentifiersFromFieldId(\n      this.props.selectedField.fieldId\n    )\n\n    return `${event}.${sectionId}.${groupId}.${this.state.handleBars}`\n  }\n\n  doesContentExist(\n    languages: ILanguageState,\n    fieldForms: IFieldForms,\n    key: string\n  ): boolean {\n    let contentExists = false\n    for (const lang in languages) {\n      const customField = fieldForms[lang]\n      if (customField[key as keyof typeof customField]) {\n        contentExists = true\n      }\n    }\n    return contentExists\n  }\n\n  populateOptionalContent(\n    fieldName: string,\n    languages: ILanguageState,\n    fieldForms: IFieldForms,\n    key: string,\n    optionalContent: IOptionalContent\n  ) {\n    if (this.doesContentExist(languages, fieldForms, key)) {\n      optionalContent[key] = []\n      for (const lang in languages) {\n        const customField = fieldForms[lang]\n        optionalContent[key].push({\n          lang,\n          descriptor: {\n            id: `form.customField.${key}.${fieldName}`,\n            description: 'Custom field attribute',\n            defaultMessage: customField[key as keyof typeof customField] || ' '\n          }\n        })\n      }\n    }\n  }\n\n  prepareModifiedFormField(): ICustomConfigField {\n    const { selectedField } = this.props\n    const { fieldForms, handleBars, conditionalField } = this.state\n    const languages = this.getLanguages()\n    const newFieldID = this.generateNewFieldID()\n\n    // later we can check the field type and not populate any content that isnt required for the type\n    const optionalContent: IOptionalContent = {}\n    this.populateOptionalContent(\n      handleBars,\n      languages,\n      fieldForms,\n      'placeholder',\n      optionalContent\n    )\n    this.populateOptionalContent(\n      handleBars,\n      languages,\n      fieldForms,\n      'description',\n      optionalContent\n    )\n    this.populateOptionalContent(\n      handleBars,\n      languages,\n      fieldForms,\n      'tooltip',\n      optionalContent\n    )\n    this.populateOptionalContent(\n      handleBars,\n      languages,\n      fieldForms,\n      'errorMessage',\n      optionalContent\n    )\n\n    const label = Object.keys(languages).map((lang) => ({\n      lang,\n      descriptor: {\n        id: `form.customField.label.${handleBars}`,\n        description: 'Custom field attribute',\n        defaultMessage: this.state.fieldForms[lang].label\n      }\n    }))\n\n    const modifiedField = {\n      ...selectedField,\n      placeholder: optionalContent.placeholder,\n      tooltip: optionalContent.tooltip,\n      description: optionalContent.description,\n      errorMessage: optionalContent.errorMessage,\n      fieldName: handleBars,\n      fieldId: newFieldID,\n      /* We can't let maxlength be 0 as it doesn't make any sense */\n      maxLength: this.state.maxLength || DEFAULT_MAX_LENGTH,\n      label\n    }\n\n    if (selectedField.conditionals) {\n      modifiedField.conditionals = [\n        {\n          fieldId: conditionalField.fieldId,\n          regexp: conditionalField.regex\n        }\n      ]\n    }\n    return modifiedField\n  }\n\n  isFieldNameDuplicate(): boolean {\n    const { fieldsMap, selectedField } = this.props\n    const newGeneratedFieldID = this.generateNewFieldID()\n\n    if (selectedField.fieldId === newGeneratedFieldID) {\n      return false\n    }\n\n    return fieldsMap.some((field) => {\n      if (isPreviewGroupConfigField(field)) {\n        return field.configFields.some(\n          ({ fieldId }) => fieldId === newGeneratedFieldID\n        )\n      }\n      return field.fieldId === newGeneratedFieldID\n    })\n  }\n\n  getHeadingText(): string {\n    const { selectedField, intl } = this.props\n\n    switch (selectedField.fieldType) {\n      case TEXT:\n        return intl.formatMessage(\n          customFieldFormMessages.customTextFieldHeading\n        )\n      case TEXTAREA:\n        return intl.formatMessage(customFieldFormMessages.customTextAreaHeading)\n      case NUMBER:\n        return intl.formatMessage(\n          customFieldFormMessages.customNumberFieldHeading\n        )\n      case TEL:\n        return intl.formatMessage(\n          customFieldFormMessages.customPhoneFieldHeading\n        )\n      case SELECT_WITH_OPTIONS:\n        return intl.formatMessage(\n          customFieldFormMessages.customSelectFieldHeading\n        )\n      default:\n        return intl.formatMessage(\n          customFieldFormMessages.customTextFieldHeading\n        )\n    }\n  }\n\n  getLanguageDropDown() {\n    const initializeLanguages = this.getLanguages()\n    const languageOptions = []\n    for (const index in initializeLanguages) {\n      languageOptions.push({\n        label: initializeLanguages[index].displayName,\n        value: index\n      })\n    }\n\n    return (\n      languageOptions.length > 1 && (\n        <FieldContainer>\n          <LanguageSelect\n            hideBorder={true}\n            value={this.state.selectedLanguage}\n            onChange={(selectedLanguage: string) => {\n              this.setState({ selectedLanguage })\n            }}\n            options={languageOptions}\n          />\n        </FieldContainer>\n      )\n    )\n  }\n\n  toggleButtons(fieldIds: string[]) {\n    const { intl, selectedField } = this.props\n    const initConditionals = [\n      {\n        fieldId: fieldIds[0],\n        regexp: EMPTY_STRING\n      }\n    ]\n    return (\n      <ListContainer>\n        <Title>{this.getHeadingText()}</Title>\n        <ListViewSimplified bottomBorder>\n          <ListViewItemSimplified\n            label={\n              <Label>\n                {intl.formatMessage(customFieldFormMessages.requiredFieldLabel)}\n                <ToolTip\n                  label={intl.formatMessage(\n                    messages.requiredForRegistrationTooltip\n                  )}\n                  id={'required-field-label'}\n                />\n              </Label>\n            }\n            actions={<RequiredToggleAction {...selectedField} />}\n          />\n          <ListViewItemSimplified\n            label={\n              <Label>\n                {intl.formatMessage(\n                  customFieldFormMessages.conditionalFieldLabel\n                )}\n                <ToolTip\n                  label={intl.formatMessage(\n                    messages.conditionalForRegistrationTooltip\n                  )}\n                  id={'conditional-field-label'}\n                />\n              </Label>\n            }\n            actions={\n              <ConditionalToggleAction\n                {...selectedField}\n                initConditionals={initConditionals}\n              />\n            }\n          />\n        </ListViewSimplified>\n      </ListContainer>\n    )\n  }\n\n  conditionalParameters(fieldIds: string[]) {\n    const { intl } = this.props\n    const fieldIdOptions = fieldIds.map((fieldId) => ({\n      value: fieldId,\n      label: fieldId\n    }))\n\n    return (\n      <FieldContainer>\n        <ConditionalWrapper>\n          <Stack>\n            <Icon name=\"GitBranch\" color=\"grey600\" />\n            <Title>\n              {intl.formatMessage(\n                customFieldFormMessages.conditionalFieldHeaderLabel\n              )}\n            </Title>\n          </Stack>\n          <Text variant=\"reg14\" element=\"span\" color=\"grey500\">\n            {intl.formatMessage(customFieldFormMessages.conditionalFieldDesc)}\n          </Text>\n          <>\n            <ConditionalFieldIdSelect\n              id=\"selectConditionalField\"\n              isDisabled={false}\n              onChange={(val: string) => {\n                this.setConditionalFieldId(val)\n                this.props.modifyConfigField(this.props.selectedField.fieldId, {\n                  conditionals: [\n                    {\n                      fieldId: val,\n                      regexp: this.state.conditionalField.regex\n                    }\n                  ]\n                })\n              }}\n              value={\n                this.state.conditionalField.fieldId ||\n                this.setConditionalFieldId(fieldIds[0])\n              }\n              options={fieldIdOptions}\n            />\n          </>\n          <CInputField\n            id={`conditional-regex-input`}\n            required={true}\n            label={intl.formatMessage(\n              customFieldFormMessages.conditionalRegexField\n            )}\n            touched={true}\n          >\n            <CTextInput\n              value={this.state.conditionalField.regex}\n              onChange={(event: React.ChangeEvent<HTMLInputElement>) =>\n                this.setState({\n                  conditionalField: {\n                    fieldId: this.state.conditionalField.fieldId,\n                    regex: event.target.value.replaceAll('\"', '')\n                  }\n                })\n              }\n            />\n          </CInputField>\n        </ConditionalWrapper>\n      </FieldContainer>\n    )\n  }\n\n  inputFields() {\n    const { intl, formField } = this.props\n    const languages = this.getLanguages()\n    const defaultLanguage = getDefaultLanguage()\n    return (\n      <>\n        {this.getLanguageDropDown()}\n        {Object.keys(languages).map((language, index) => {\n          return (\n            <React.Fragment key={index}>\n              <FieldContainer hide={language !== this.state.selectedLanguage}>\n                <CInputField\n                  id={`custom-form-label-${language}`}\n                  label={intl.formatMessage(customFieldFormMessages.label)}\n                  touched={true}\n                >\n                  <CTextInput\n                    value={this.state.fieldForms[language].label}\n                    onChange={(event: any) => {\n                      const { value } = event.target\n                      this.setState({\n                        handleBars:\n                          defaultLanguage === this.state.selectedLanguage\n                            ? camelCase(\n                                value || getCertificateHandlebar(formField)\n                              )\n                            : this.state.handleBars,\n                        fieldForms: {\n                          ...this.state.fieldForms,\n                          [this.state.selectedLanguage]: {\n                            ...this.state.fieldForms[\n                              this.state.selectedLanguage\n                            ],\n                            label: value\n                          }\n                        }\n                      })\n                    }}\n                  />\n                </CInputField>\n                {this.isFieldNameDuplicate() && (\n                  <Text variant=\"reg14\" element=\"p\" color=\"red\">\n                    {intl.formatMessage(customFieldFormMessages.duplicateField)}\n                  </Text>\n                )}\n              </FieldContainer>\n\n              <FieldContainer hide={language !== this.state.selectedLanguage}>\n                <CInputField\n                  required={false}\n                  id={`custom-form-placeholder-${language}`}\n                  label={intl.formatMessage(\n                    customFieldFormMessages.placeholderLabel\n                  )}\n                  touched={false}\n                >\n                  <CTextInput\n                    value={this.state.fieldForms[language].placeholder}\n                    onChange={(event: any) =>\n                      this.setValue('placeholder', event.target.value)\n                    }\n                  />\n                </CInputField>\n              </FieldContainer>\n\n              <FieldContainer hide={language !== this.state.selectedLanguage}>\n                <CInputField\n                  id={`custom-form-description-${language}`}\n                  label={intl.formatMessage(\n                    customFieldFormMessages.descriptionLabel\n                  )}\n                  required={false}\n                  touched={false}\n                >\n                  <CTextArea\n                    ignoreMediaQuery={true}\n                    {...{\n                      onChange: (event: any) => {\n                        this.setValue('description', event.target.value)\n                      },\n                      value: this.state.fieldForms[language].description\n                    }}\n                  />\n                </CInputField>\n              </FieldContainer>\n\n              <FieldContainer hide={language !== this.state.selectedLanguage}>\n                <CInputField\n                  required={false}\n                  id={`custom-form-tooltip-${language}`}\n                  label={intl.formatMessage(\n                    customFieldFormMessages.tooltipLabel\n                  )}\n                  touched={false}\n                >\n                  <CTextInput\n                    onChange={(event: any) =>\n                      this.setValue('tooltip', event.target.value)\n                    }\n                    value={this.state.fieldForms[language].tooltip}\n                  />\n                </CInputField>\n              </FieldContainer>\n\n              {/*errorMessage is not implemented yet*/}\n              {/*\n              <FieldContainer hide={language !== this.state.selectedLanguage}>\n                <CInputField\n                  required={false}\n                  id={`custom-form-error-message-${language}`}\n                  label={intl.formatMessage(\n                    customFieldFormMessages.errorMessage\n                  )}\n                  touched={false}\n                >\n                  <CTextArea\n                    ignoreMediaQuery={true}\n                    {...{\n                      onChange: (event: any) => {\n                        this.setValue('errorMessage', event.target.value)\n                      },\n                      value: this.state.fieldForms[language].errorMessage\n                    }}\n                  />\n                </CInputField>\n              </FieldContainer>\n            */}\n            </React.Fragment>\n          )\n        })}\n        <FieldContainer>\n          <CInputField\n            required={false}\n            id=\"custom-form-max-length\"\n            label={intl.formatMessage(customFieldFormMessages.maxLengthLabel)}\n            touched={false}\n          >\n            <CTextInput\n              type=\"number\"\n              defaultValue={this.state.maxLength}\n              onChange={(event: { target: { value: string | number } }) =>\n                this.setState({\n                  maxLength: +event.target.value\n                })\n              }\n            />\n          </CInputField>\n        </FieldContainer>\n      </>\n    )\n  }\n\n  showErrorMessage(errCode: string) {\n    const { intl } = this.props\n    const messages: IntlMessages = {\n      SUCCESSFUL: intl.formatMessage(customFieldFormMessages.statusValidated),\n      NO_DATA_FOUND: intl.formatMessage(\n        customFieldFormMessages.statusNoDataFound\n      ),\n      TRANSLATION_MISSING: intl.formatMessage(\n        customFieldFormMessages.statusTranslationMissing\n      ),\n      FAILED: intl.formatMessage(customFieldFormMessages.statusFailed)\n    }\n\n    if (errCode in messages) return messages[errCode]\n    return messages.FAILED\n  }\n\n  selectField() {\n    const { intl, formField } = this.props\n    const languages = this.getLanguages()\n    const defaultLanguage = getDefaultLanguage()\n\n    return (\n      <>\n        <Text variant=\"bold16\" element=\"p\">\n          <CustomSelectHeading>\n            <Icon color=\"currentColor\" name=\"TextT\" size=\"large\" />\n            {intl.formatMessage(customFieldFormMessages.copyHeading)}\n          </CustomSelectHeading>\n        </Text>\n        <Text color=\"grey500\" variant=\"reg14\" element=\"span\">\n          {intl.formatMessage(customFieldFormMessages.copyDescription)}\n        </Text>\n        <br></br>\n        <br></br>\n\n        {this.getLanguageDropDown()}\n\n        {Object.keys(languages).map((language, index) => {\n          return (\n            <React.Fragment key={index}>\n              <FieldContainer hide={language !== this.state.selectedLanguage}>\n                <CInputField\n                  id={`custom-form-label-${language}`}\n                  label={intl.formatMessage(customFieldFormMessages.label)}\n                  touched={true}\n                >\n                  <CTextInput\n                    value={this.state.fieldForms[language].label}\n                    onChange={(event: any) => {\n                      const { value } = event.target\n                      this.setState({\n                        handleBars:\n                          defaultLanguage === this.state.selectedLanguage\n                            ? camelCase(\n                                value || getCertificateHandlebar(formField)\n                              )\n                            : this.state.handleBars,\n                        fieldForms: {\n                          ...this.state.fieldForms,\n                          [this.state.selectedLanguage]: {\n                            ...this.state.fieldForms[\n                              this.state.selectedLanguage\n                            ],\n                            label: value\n                          }\n                        }\n                      })\n                    }}\n                  />\n                </CInputField>\n              </FieldContainer>\n            </React.Fragment>\n          )\n        })}\n\n        <Text variant=\"bold16\" element=\"p\">\n          <CustomSelectHeading>\n            <Icon color=\"currentColor\" name=\"Database\" size=\"large\" />\n            {intl.formatMessage(customFieldFormMessages.dataSourceHeading)}\n          </CustomSelectHeading>\n        </Text>\n        <Text color=\"grey500\" variant=\"reg14\" element=\"span\">\n          {intl.formatMessage(customFieldFormMessages.dataSourceDescription)}\n          &nbsp;\n        </Text>\n        <Link\n          onClick={() => {\n            window.open('https://documentation.opencrvs.org/', '_blank')\n          }}\n          font=\"reg14\"\n        >\n          documentation.opencrvs.org\n        </Link>\n        {this.CSVUploadModal()}\n\n        <CSelect\n          value={this.state.selectedDataSource}\n          onChange={(selectedDataSource: string) => {\n            this.dataSourceSelected(selectedDataSource)\n          }}\n          options={this.state.dataSourceSelectOptions.map((option) => ({\n            label: option.label,\n            value: option.value\n          }))}\n        />\n\n        <FileSelectLink\n          id=\"upload-data-source\"\n          accept=\".csv\"\n          handleFileChange={this.onFileChangeHandler.bind(this)}\n          title={intl.formatMessage(buttonMessages.upload)}\n        />\n        <br></br>\n        <br></br>\n      </>\n    )\n  }\n\n  dataSourceSelected(selectedDataSource: string) {\n    const { selectedField, modifyConfigField, formDataset } = this.props\n\n    const dataSourceSelectOptions = this.prepareDataSourceOptions(\n      formDataset || []\n    )\n    this.setState({ selectedDataSource, dataSourceSelectOptions })\n\n    const options = dataSourceSelectOptions.find(\n      (option) => option.value === selectedDataSource\n    )\n\n    const modifiedField = {\n      options: options ? (options.options as ICustomSelectOption[]) : [],\n      datasetId: selectedDataSource\n    }\n    modifyConfigField(selectedField.fieldId, modifiedField)\n  }\n\n  async onFileChangeHandler(file: File) {\n    const { intl, offlineFormConfigAddFormDataset } = this.props\n    try {\n      const encodedFile = await getBase64String(file)\n      const base64Data = (encodedFile as string).split(',')[1]\n      const fileName = file.name\n\n      this.setState({\n        showCSVUploadingModal: true,\n        CSVUploadStatuses: [\n          {\n            message: intl.formatMessage(\n              customFieldFormMessages.statusValidating\n            ),\n            statusType: STATUS_TYPES.INPROGRESS\n          }\n        ]\n      })\n      const res = await client.mutate<CreateFormDatasetMutation>({\n        mutation: CREATE_FORM_DATA_SET,\n        variables: { formDataset: { fileName, base64Data } }\n      })\n\n      if (res?.data?.createFormDataset?.data?._id) {\n        const { _id, fileName, options } = res.data.createFormDataset.data\n        const newDataSource: IFormDataSet = {\n          _id,\n          fileName,\n          options: options as ICustomSelectOption[]\n        }\n        offlineFormConfigAddFormDataset(newDataSource)\n        this.dataSourceSelected(res.data.createFormDataset.data._id)\n      }\n      this.setState({\n        CSVUploaderModalActions: [],\n        CSVUploadStatuses: [\n          {\n            message: intl.formatMessage(\n              customFieldFormMessages.statusValidated\n            ),\n            statusType: STATUS_TYPES.COMPLETED\n          },\n          {\n            message: intl.formatMessage(\n              customFieldFormMessages.statusAppliedToCustomSelect\n            ),\n            statusType: STATUS_TYPES.COMPLETED\n          }\n        ]\n      })\n    } catch (ex: any) {\n      this.setState({\n        CSVUploadStatuses: [\n          {\n            message: this.showErrorMessage(ex.message as string),\n            statusType: STATUS_TYPES.ERROR\n          }\n        ],\n        CSVUploaderModalActions: [\n          <Button onClick={this.closeCSVUploadModal.bind(this)} type=\"tertiary\">\n            {intl.formatMessage(buttonMessages.cancel)}\n          </Button>,\n          <CFileSelectLink\n            id=\"upload-data-source\"\n            accept=\".csv\"\n            handleFileChange={this.onFileChangeHandler.bind(this)}\n            title={intl.formatMessage(buttonMessages.upload)}\n          />\n        ]\n      })\n    }\n  }\n\n  saveButton() {\n    const { intl, selectedField, modifyConfigField, setSelectedField } =\n      this.props\n    const debouncedNullifySelectedField = debounce(() => {\n      setSelectedField(null)\n    }, 300)\n\n    return (\n      <ListContainer>\n        <ListRow>\n          <ListColumn>\n            <CPrimaryButton\n              id={'custom-tool-save-button'}\n              onClick={() => {\n                const modifiedField = this.prepareModifiedFormField()\n                modifyConfigField(selectedField.fieldId, modifiedField)\n                debouncedNullifySelectedField()\n              }}\n              disabled={\n                !this.isFormValid() ||\n                !this.isConditionalFormValid() ||\n                this.isFieldNameDuplicate()\n              }\n            >\n              {intl.formatMessage(buttonMessages.save)}\n            </CPrimaryButton>\n          </ListColumn>\n        </ListRow>\n      </ListContainer>\n    )\n  }\n\n  closeCSVUploadModal() {\n    this.setState({ showCSVUploadingModal: false })\n  }\n\n  CSVUploadModal() {\n    const { intl } = this.props\n    return (\n      <ResponsiveModal\n        title={intl.formatMessage(customFieldFormMessages.validatingCSVFile)}\n        handleClose={this.closeCSVUploadModal.bind(this)}\n        show={this.state.showCSVUploadingModal}\n        actions={this.state.CSVUploaderModalActions}\n      >\n        <>\n          {intl.formatMessage(\n            customFieldFormMessages.validatingCSVFilesValidatingDescription\n          )}\n          <br />\n          <br />\n\n          {this.state.CSVUploadStatuses.map((status, key) => {\n            return (\n              <>\n                <Alert\n                  key={key}\n                  onActionClick={() => {}}\n                  type={status.statusType}\n                >\n                  {status.message}\n                </Alert>\n                <br />\n              </>\n            )\n          })}\n        </>\n      </ResponsiveModal>\n    )\n  }\n\n  showHandlebar() {\n    const { selectedField, intl } = this.props\n    const customHandlebarName = createCustomFieldHandlebarName(\n      selectedField.fieldId\n    )\n    return (\n      <Body>\n        <Stack>\n          <Text variant=\"bold14\" element=\"span\" color=\"grey600\">\n            {intl.formatMessage(customFieldFormMessages.handleBardHeading)}\n          </Text>\n          <ToolTip\n            label={intl.formatMessage(messages.certHandelbarsTooltip)}\n            id={'cert-handelbars'}\n          />\n        </Stack>\n        <Text variant=\"reg14\" element=\"span\" color=\"grey500\">\n          {`{{ ${customHandlebarName} }}`}\n        </Text>\n      </Body>\n    )\n  }\n\n  render(): React.ReactNode {\n    const { intl, selectedField } = this.props\n    return (\n      <>\n        <RegisterFormFieldIds>\n          {(fieldIds: string[]) => (\n            <>\n              {this.toggleButtons(fieldIds)}\n              {!isEmpty(selectedField.conditionals) &&\n                this.conditionalParameters(fieldIds)}\n            </>\n          )}\n        </RegisterFormFieldIds>\n\n        {selectedField.fieldType !== SELECT_WITH_OPTIONS && this.inputFields()}\n        {selectedField.fieldType === SELECT_WITH_OPTIONS && this.selectField()}\n        {this.saveButton()}\n        {this.showHandlebar()}\n      </>\n    )\n  }\n}\n\nfunction withFieldDefinition<T extends { selectedField: ICustomConfigField }>(\n  WrappedComponent: React.ComponentType<T & IFormFieldWrapper>\n) {\n  return function WithFieldDefinition(props: T) {\n    const formField = useFieldDefinition(props.selectedField)\n    return <WrappedComponent formField={formField} {...props} />\n  }\n}\n\nconst mapStateToProps = (store: IStoreState, props: IProps) => {\n  const { event, section } = props\n  return {\n    fieldsMap: selectConfigFields(store, event, section),\n    facilities: store.offline.offlineData.facilities,\n    selectedLanguage: store.i18n.language,\n    formDataset: store.formConfig.formDataset\n  }\n}\n\nconst mapDispatchToProps = {\n  modifyConfigField,\n  offlineFormConfigAddFormDataset\n}\n\nexport const CustomFieldTools = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(injectIntl(withFieldDefinition(CustomFieldToolsComp)))\n"
        }
    ]
}